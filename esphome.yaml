esphome:
  name: "${name}"
  friendly_name: "${friendly_name}"

# Enable logging
logger:
  level: DEBUG
  # Disable UART logging to avoid conflicts with UART component
  baud_rate: 0

# Enable Home Assistant API
api:
  encryption:

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Kiisu-Connect Fallback Hotspot"
    password: "123423423"

captive_portal:

web_server:
  port: 80

# UART configuration for RX and TX pins
uart:
  id: uart_bus
  tx_pin: GPIO5   # TX pin on QT Py ESP32-S2
  rx_pin: GPIO16  # RX pin on QT Py ESP32-S2  
  baud_rate: 115200
  debug:
    direction: BOTH
    dummy_receiver: false
    after:
      delimiter: "\n"
    sequence:
      - lambda: |-
          // Log the UART traffic
          UARTDebug::log_string(direction, bytes);
          
          // Also log with custom prefixes for clarity
          std::string str(bytes.begin(), bytes.end());
          if (direction == uart::UART_DIRECTION_TX) {
            ESP_LOGI("uart", "TX>> %s", str.c_str());
          } else if (direction == uart::UART_DIRECTION_RX) {
            ESP_LOGI("uart", "RX<< %s", str.c_str());
          }

# Sensor configuration with all data types from Flipper Zero
sensor:
  # Accelerometer X, Y, Z (float values in m/s²)
  - platform: template
    name: "Accel X"
    id: accel_x
    unit_of_measurement: "m/s²"
    accuracy_decimals: 3
    state_class: "measurement"

  - platform: template
    name: "Accel Y"
    id: accel_y
    unit_of_measurement: "m/s²"
    accuracy_decimals: 3
    state_class: "measurement"

  - platform: template
    name: "Accel Z"
    id: accel_z
    unit_of_measurement: "m/s²"
    accuracy_decimals: 3
    state_class: "measurement"

  # Magnetometer X, Y, Z (float values in µT)
  - platform: template
    name: "Magnetometer X"
    id: mag_x
    unit_of_measurement: "µT"
    accuracy_decimals: 3
    state_class: "measurement"

  - platform: template
    name: "Magnetometer Y"
    id: mag_y
    unit_of_measurement: "µT"
    accuracy_decimals: 3
    state_class: "measurement"

  - platform: template
    name: "Magnetometer Z"
    id: mag_z
    unit_of_measurement: "µT"
    accuracy_decimals: 3
    state_class: "measurement"

  # Heading (float value in degrees)
  - platform: template
    name: "Heading"
    id: heading
    unit_of_measurement: "°"
    accuracy_decimals: 1
    state_class: "measurement"
    icon: "mdi:compass"

  # Temperature (float value in °C)
  - platform: template
    name: "Temperature"
    id: temperature
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    device_class: "temperature"
    state_class: "measurement"

  # Humidity (float value in %)
  - platform: template
    name: "Humidity"
    id: humidity
    unit_of_measurement: "%"
    accuracy_decimals: 1
    device_class: "humidity"
    state_class: "measurement"

  # Light sensor percent (float value in %)
  - platform: template
    name: "Light Percent"
    id: light_percent
    unit_of_measurement: "%"
    accuracy_decimals: 1
    state_class: "measurement"
    icon: "mdi:brightness-percent"

  # Light sensor voltage (float value in mV)
  - platform: template
    name: "Light Voltage"
    id: light_voltage
    unit_of_measurement: "mV"
    accuracy_decimals: 1
    state_class: "measurement"

# Binary sensors for status indicators (OK flags)
binary_sensor:
  - platform: template
    name: "Accelerometer OK"
    id: accel_ok

  - platform: template
    name: "Magnetometer OK"
    id: mag_ok

  - platform: template
    name: "Temperature OK"
    id: temp_ok

  - platform: template
    name: "Humidity OK"
    id: humidity_ok

  - platform: template
    name: "Light Sensor OK"
    id: light_ok

# Interval component to automatically send "data" command every minute
interval:
  - interval: 1min
    then:
      - lambda: |-
          ESP_LOGI("uart", "Auto-sending data command");
          id(uart_bus).write_str("data\n");

# Text input for sending commands
text:
  - platform: template
    name: "Send Data"
    id: uart_command
    optimistic: true
    min_length: 0
    max_length: 100
    mode: text
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("uart", "Sending: %s", x.c_str());
            id(uart_bus).write_str("data\n");

# Button to send the command
button:
  - platform: template
    name: "Send"
    on_press:
      then:
        - lambda: |-
            std::string cmd = id(uart_command).state;
            ESP_LOGI("uart", "Sending: %s", cmd.c_str());
            id(uart_bus).write_str("data\n");
            id(uart_command).publish_state("");

# Select for common Kiisu data commands
select:
  - platform: template
    name: "Quick Data"
    id: quick_commands
    optimistic: true
    options:
      - "Select Data"
      - "data"
    initial_option: "Select Data"
    on_value:
      then:
        - lambda: |-
            if (x != "Select Data" && x.length() > 0) {
              ESP_LOGI("uart", "Quick data: %s", x.c_str());
              id(uart_bus).write_str(x.c_str());
              id(uart_bus).write_str("\n");
            
              // Reset to default after sending
              auto call = id(quick_commands).make_call();
              call.set_option("Select Data");
              call.perform();
            }

# Custom component for additional UART reading and sensor value parsing
custom_component:
  - lambda: |-
      class UARTReader : public Component, public UARTDevice {
       private:
        std::string buffer;
        unsigned long last_byte_time = 0;
        const unsigned long timeout_ms = 100;
      
        void parse_sensor_line(const std::string &line) {
          // Parse incoming sensor data lines and update template sensors
          if (line.find("accel_x=") == 0) {
            float value = std::stof(line.substr(8));
            id(accel_x).publish_state(value);
          } else if (line.find("accel_y=") == 0) {
            float value = std::stof(line.substr(8));
            id(accel_y).publish_state(value);
          } else if (line.find("accel_z=") == 0) {
            float value = std::stof(line.substr(8));
            id(accel_z).publish_state(value);
          } else if (line.find("accel_ok=") == 0) {
            bool value = std::stoi(line.substr(9)) == 1;
            id(accel_ok).publish_state(value);
          } else if (line.find("mag_x=") == 0) {
            float value = std::stof(line.substr(6));
            id(mag_x).publish_state(value);
          } else if (line.find("mag_y=") == 0) {
            float value = std::stof(line.substr(6));
            id(mag_y).publish_state(value);
          } else if (line.find("mag_z=") == 0) {
            float value = std::stof(line.substr(6));
            id(mag_z).publish_state(value);
          } else if (line.find("mag_ok=") == 0) {
            bool value = std::stoi(line.substr(7)) == 1;
            id(mag_ok).publish_state(value);
          } else if (line.find("heading=") == 0) {
            float value = std::stof(line.substr(8));
            id(heading).publish_state(value);
          } else if (line.find("temperature=") == 0) {
            float value = std::stof(line.substr(12));
            id(temperature).publish_state(value);
          } else if (line.find("temp_ok=") == 0) {
            bool value = std::stoi(line.substr(8)) == 1;
            id(temp_ok).publish_state(value);
          } else if (line.find("humidity=") == 0) {
            float value = std::stof(line.substr(9));
            id(humidity).publish_state(value);
          } else if (line.find("humidity_ok=") == 0) {
            bool value = std::stoi(line.substr(12)) == 1;
            id(humidity_ok).publish_state(value);
          } else if (line.find("light_percent=") == 0) {
            float value = std::stof(line.substr(14));
            id(light_percent).publish_state(value);
          } else if (line.find("light_voltage=") == 0) {
            float value = std::stof(line.substr(14));
            id(light_voltage).publish_state(value);
          } else if (line.find("light_ok=") == 0) {
            bool value = std::stoi(line.substr(9)) == 1;
            id(light_ok).publish_state(value);
          }
        }
      
       public:
        UARTReader(UARTComponent *parent) : UARTDevice(parent) {}
      
        void setup() override {
          ESP_LOGI("uart_reader", "UART Bridge Ready");
          ESP_LOGI("uart_reader", "TX: GPIO5, RX: GPIO16, Baud: 115200");
          ESP_LOGI("uart_reader", "Access web interface to send data");
          ESP_LOGI("uart_reader", "Auto-polling enabled every 1 minute");
        }
      
        void loop() override {
          // Read all available bytes
          while (available()) {
            uint8_t byte = read();
      
            // Handle printable characters
            if (byte >= 32 && byte <= 126) {
              buffer += (char)byte;
            }
            // Handle newline/carriage return
            else if (byte == '\n') {
              if (!buffer.empty()) {
                ESP_LOGI("response", "%s", buffer.c_str());
      
                // Parse sensor data and update template sensors
                parse_sensor_line(buffer);
      
                buffer.clear();
              }
            }
            // Handle other control characters
            else if (byte != 0) {
              // Log non-printable characters as hex
              ESP_LOGV("uart_reader", "Control char: 0x%02X", byte);
            }
      
            last_byte_time = millis();
      
            // Prevent buffer overflow
            if (buffer.length() > 512) {
              ESP_LOGW("uart_reader", "Buffer overflow, flushing");
              ESP_LOGI("response", "%s", buffer.c_str());
              parse_sensor_line(buffer);
              buffer.clear();
            }
          }
      
          // Timeout handling - flush buffer if no new data for a while
          if (!buffer.empty() && (millis() - last_byte_time) > timeout_ms) {
            ESP_LOGI("response", "%s", buffer.c_str());
            parse_sensor_line(buffer);
            buffer.clear();
          }
        }
      };
      
      auto reader = new UARTReader(id(uart_bus));
      return {reader};